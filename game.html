<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Saf's Minigame Arcade</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&family=Press+Start+2P&display=swap" rel="stylesheet">

    <style>
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(to bottom right, #60a5fa, #3b82f6); /* Gradient background */
            color: #333;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            padding-top: 70px; /* Space for fixed header */
        }

        header {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            z-index: 50; /* Ensure header is on top */
        }

        .game-container {
            flex-grow: 1;
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Align items to the top - this container centers the game-area */
            padding: 20px;
            overflow-y: auto; /* Allow scrolling if game content is large */
        }

        #game-area {
             background-color: rgba(255, 255, 255, 0.95); /* Slightly transparent white */
             backdrop-filter: blur(5px); /* Frosted glass effect */
             border-radius: 12px; /* More rounded corners */
             box-shadow: 0 10px 15px rgba(0, 0, 0, 0.2); /* Stronger shadow */
             padding: 30px; /* More padding */
             display: flex; /* Make game-area a flex container */
             flex-direction: column; /* Stack children vertically */
             justify-content: center; /* Center children horizontally */
             align-items: center; /* Center children vertically */
        }

        /* Custom styles for game boards/elements */
        #tic-tac-toe-board {
            display: grid;
            grid-template-columns: repeat(3, minmax(80px, 1fr)); /* Responsive grid */
            grid-template-rows: repeat(3, minmax(80px, 1fr));
            gap: 8px; /* Increased gap */
            margin-top: 20px;
            max-width: 300px; /* Max width for the board */
            width: 100%;
        }

        .tic-tac-toe-cell {
            width: 100%; /* Fill grid cell */
            height: 100%; /* Fill grid cell */
            background-color: #e2e8f0; /* Lighter background */
            border: 3px solid #4a5568; /* Darker border */
            border-radius: 8px; /* Rounded cell corners */
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 3.5em; /* Slightly larger font */
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.1s ease;
            color: #2d3748; /* Darker text color */
        }

        .tic-tac-toe-cell:hover {
            background-color: #cbd5e0; /* Hover effect */
            transform: scale(1.05); /* Slight scale on hover */
        }

        #tetris-board {
            border: 4px solid #4a5568; /* Thicker border */
            background-color: #1a202c; /* Darker background */
            margin-top: 20px;
            border-radius: 8px; /* Rounded corners for canvas */
            /* Size will be set by JS, but ensure it's responsive */
            display: block; /* Remove extra space below canvas */
            max-width: 100%; /* Ensure it doesn't overflow */
            height: auto; /* Maintain aspect ratio */
        }

         #ping-pong-board,
         #projectile-board {
             border: 4px solid #4a5568; /* Thicker border */
             background-color: #1a202c; /* Darker background */
             margin-top: 20px;
             border-radius: 8px; /* Rounded corners for canvas */
             display: block;
             max-width: 100%;
             height: auto;
         }


        #card-matching-board {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 15px; /* Increased gap */
            margin-top: 20px;
            max-width: 700px; /* Increased max width */
            width: 100%;
            justify-content: center; /* Center cards in the grid */
        }

        .card {
            width: 100%; /* Make card width responsive within grid cell */
            padding-bottom: 140%; /* Maintain aspect ratio (height is 140% of width) */
            background-color: #4a5568; /* Card back color */
            border-radius: 10px; /* More rounded corners */
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            cursor: pointer;
            transform-style: preserve-3d;
            transition: transform 0.6s;
            position: relative;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); /* Add shadow */
        }

        .card.flipped {
            transform: rotateY(180deg);
        }

        .card .card-inner {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            text-align: center;
            /* backface-visibility: hidden; REMOVED - Handled by rotating front/back */
            border-radius: 10px; /* Match parent border-radius */
            overflow: hidden; /* Hide overflowing content */
        }

        .card .card-front,
        .card .card-back {
             position: absolute;
             width: 100%;
             height: 100%;
             top: 0;
             left: 0;
             backface-visibility: hidden; /* Hide the back side when not facing the viewer */
             display: flex;
             justify-content: center;
             align-items: center;
             border-radius: 10px; /* Match parent border-radius */
        }


        .card .card-front {
            background-color: #fff; /* Card face color */
            color: #333;
            transform: rotateY(180deg) scaleX(-1); /* Initially rotated away and inverted */
            font-size: 2em; /* Adjusted font size for letters */
            font-weight: bold;
        }

         .card.flipped .card-front {
             transform: rotateY(0deg) scaleX(-1); /* Face the viewer when card is flipped, still inverted */
         }


         .card .card-back {
            background-color: #4a5568; /* Card back color */
            color: white;
             font-family: 'Press Start 2P', cursive; /* Arcade font for back */
             font-size: 1.5em;
             transform: rotateY(0deg); /* Initially facing the viewer */
        }

        .card.flipped .card-back {
            transform: rotateY(180deg); /* Rotate away when card is flipped */
        }


        .card.matched .card-front {
             background-color: #9ae6b4; /* Matched card color */
        }


        /* Message Box Styling */
        .message-box {
            position: fixed;
            top: 80px; /* Position below the fixed header */
            left: 50%;
            transform: translateX(-50%);
            background-color: #4a5568;
            color: white;
            padding: 15px 20px;
            border-radius: 8px;
            z-index: 1000;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
        }

        .message-box.show {
            opacity: 1;
        }

        /* Button Styling */
        button {
            font-family: 'Press Start 2P', cursive; /* Arcade font for buttons */
            padding: 12px 24px;
            border-radius: 8px;
            transition: background-color 0.2s ease, transform 0.1s ease;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.15);
        }

        button:active {
             transform: translateY(0);
             box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .bg-blue-500 { background-color: #3b82f6; }
        .hover\:bg-blue-600:hover { background-color: #2563eb; }
        .bg-green-500 { background-color: #22c55e; }
        .hover\:bg-green-600:hover { background-color: #16a34a; }
        .bg-yellow-500 { background-color: #f59e0b; }
        .hover\:bg-yellow-600:hover { background-color: #d97706; }


    </style>
</head>
<body class="flex flex-col min-h-screen">

    <header class="bg-blue-700 text-white p-4 shadow-xl">
        <div class="container mx-auto flex flex-col md:flex-row justify-between items-center">
            <h1 class="text-3xl font-bold mb-2 md:mb-0 font-['Press_Start_2P']">Bagel's Arcade</h1>
            <nav>
                <ul class="flex flex-wrap justify-center md:justify-start space-x-4 text-lg">
                    <li><a href="#" class="game-link hover:underline hover:text-blue-200 transition-colors duration-200" data-game="tic-tac-toe">Tic Tac Toe</a></li>
                    <li><a href="#" class="game-link hover:underline hover:text-blue-200 transition-colors duration-200" data-game="tetris">Tetris</a></li>
                    <li><a href="#" class="game-link hover:underline hover:text-blue-200 transition-colors duration-200" data-game="card-matching">Card Matching</a></li>
                     <li><a href="#" class="game-link hover:underline hover:text-blue-200 transition-colors duration-200" data-game="ping-pong">Ping Pong</a></li>
                     <li><a href="#" class="game-link hover:underline hover:text-blue-200 transition-colors duration-200" data-game="projectile">Projectile Game</a></li>
                </ul>
            </nav>
        </div>
    </header>

    <main class="game-container container mx-auto">
        <div id="game-area" class="w-full max-w-4xl p-6">
            <h2 class="text-2xl font-semibold text-center mb-4 text-gray-800">Select a game from the menu above!</h2>
            </div>
    </main>

    <div id="message-box" class="message-box"></div>


    <script>
        // Get the game area div
        const gameArea = document.getElementById('game-area');
        const messageBox = document.getElementById('message-box');

        // Function to display messages
        function showMessage(message, duration = 3000) {
            messageBox.textContent = message;
            messageBox.classList.add('show');
            setTimeout(() => {
                messageBox.classList.remove('show');
            }, duration);
        }


        // --- Game Implementations ---

        // Tic Tac Toe Game
        function loadTicTacToe() {
            gameArea.innerHTML = `
                <h2 class="text-2xl font-semibold text-center mb-6 text-gray-800">Tic Tac Toe</h2>
                <div id="tic-tac-toe-board" class="mx-auto">
                    <div class="tic-tac-toe-cell" data-index="0"></div>
                    <div class="tic-tac-toe-cell" data-index="1"></div>
                    <div class="tic-tac-toe-cell" data-index="2"></div>
                    <div class="tic-tac-toe-cell" data-index="3"></div>
                    <div class="tic-tac-toe-cell" data-index="4"></div>
                    <div class="tic-tac-toe-cell" data-index="5"></div>
                    <div class="tic-tac-toe-cell" data-index="6"></div>
                    <div class="tic-tac-toe-cell" data-index="7"></div>
                    <div class="tic-tac-toe-cell" data-index="8"></div>
                </div>
                <p id="tic-tac-toe-status" class="text-center mt-6 text-xl text-gray-700 font-semibold"></p>
                 <button id="tic-tac-toe-reset" class="block mx-auto mt-8 px-6 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50">Reset Game</button>
            `;

            const cells = document.querySelectorAll('.tic-tac-toe-cell');
            const statusDisplay = document.getElementById('tic-tac-toe-status');
            const resetButton = document.getElementById('tic-tac-toe-reset');

            let board = ['', '', '', '', '', '', '', '', ''];
            let currentPlayer = 'X';
            let gameActive = true;

            // Winning conditions
            const winningConditions = [
                [0, 1, 2], [3, 4, 5], [6, 7, 8], // Rows
                [0, 3, 6], [1, 4, 7], [2, 5, 8], // Columns
                [0, 4, 8], [2, 4, 6]             // Diagonals
            ];

            // Handle cell click
            function handleCellClick(event) {
                const clickedCell = event.target;
                const clickedCellIndex = parseInt(clickedCell.getAttribute('data-index'));

                // If the cell is already filled or game is inactive, do nothing
                if (board[clickedCellIndex] !== '' || !gameActive) {
                    return;
                }

                // Update the board and display
                board[clickedCellIndex] = currentPlayer;
                clickedCell.textContent = currentPlayer;
                 clickedCell.style.color = currentPlayer === 'X' ? '#ef4444' : '#3b82f6'; // Red for X, Blue for O

                // Check for win or draw
                checkResult();

                // Switch player
                if (gameActive) { // Only switch player if game is still active
                    currentPlayer = currentPlayer === 'X' ? 'O' : 'X';
                    updateStatus();
                }
            }

            // Check for win or draw
            function checkResult() {
                let roundWon = false;
                for (let i = 0; i < winningConditions.length; i++) {
                    const winCondition = winningConditions[i];
                    const a = board[winCondition[0]];
                    const b = board[winCondition[1]];
                    const c = board[winCondition[2]];

                    if (a === '' || b === '' || c === '') {
                        continue;
                    }
                    if (a === b && b === c) {
                        roundWon = true;
                        // Highlight winning cells
                        winCondition.forEach(index => {
                            cells[index].style.backgroundColor = '#fde047'; // Yellow highlight
                        });
                        break;
                    }
                }

                if (roundWon) {
                    statusDisplay.textContent = `Player ${currentPlayer} wins!`;
                    showMessage(`Player ${currentPlayer} wins!`);
                    gameActive = false;
                    return;
                }

                // Check for draw
                if (!board.includes('')) {
                    statusDisplay.textContent = 'Draw!';
                    showMessage('Draw!');
                    gameActive = false;
                    return;
                }
            }

            // Update the status display
            function updateStatus() {
                if (gameActive) {
                    statusDisplay.textContent = `Player ${currentPlayer}'s turn`;
                }
            }

            // Reset the game
            function resetGame() {
                board = ['', '', '', '', '', '', '', '', ''];
                gameActive = true;
                currentPlayer = 'X';
                cells.forEach(cell => {
                    cell.textContent = '';
                    cell.style.backgroundColor = '#e2e8f0'; // Reset background color
                    cell.style.color = '#2d3748'; // Reset text color
                });
                updateStatus();
                 showMessage('Tic Tac Toe game reset.');
            }

            // Add event listeners
            cells.forEach(cell => cell.addEventListener('click', handleCellClick));
            resetButton.addEventListener('click', resetGame);

            // Initial status display
            updateStatus();
        }

        // Tetris Game
        function loadTetris() {
             gameArea.innerHTML = `
                <h2 class="text-2xl font-semibold text-center mb-6 text-gray-800">Tetris</h2>
                <canvas id="tetris-board"></canvas>
                <p id="tetris-score" class="text-center mt-4 text-xl text-gray-700 font-semibold font-['Press_Start_2P']">Score: 0</p>
                <div class="text-center mt-6 space-x-4">
                    <button id="tetris-start" class="px-6 py-3 bg-green-600 text-white rounded-lg hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-opacity-50">Start</button>
                    <button id="tetris-pause" class="px-6 py-3 bg-yellow-600 text-white rounded-lg hover:bg-yellow-700 focus:outline-none focus:ring-2 focus:ring-yellow-500 focus:ring-opacity-50">Pause</button>
                </div>
                 <p class="text-center mt-4 text-gray-600 text-sm">Use Arrow Keys to move and rotate.</p>
            `;

            const canvas = document.getElementById('tetris-board');
            const context = canvas.getContext('2d');
            const scoreDisplay = document.getElementById('tetris-score');
            const startButton = document.getElementById('tetris-start');
            const pauseButton = document.getElementById('tetris-pause');

            // Tetris board dimensions (in blocks)
            const boardWidth = 10; // Standard Tetris width
            const boardHeight = 20; // Standard Tetris height

            // Set canvas size based on block size and board dimensions
            const blockSize = 30; // Pixels per block
            canvas.width = boardWidth * blockSize;
            canvas.height = boardHeight * blockSize;

            // Scale the context for drawing blocks
            context.scale(blockSize, blockSize);

            // Initialize the board with empty blocks
            const board = Array(boardHeight).fill(null).map(() => Array(boardWidth).fill(0));

            // Tetromino shapes and colors
            const tetrominoes = [
                [[0, 0, 0, 0], [1, 1, 1, 1], [0, 0, 0, 0], [0, 0, 0, 0]], // I (Cyan)
                [[2, 2], [2, 2]],                                        // O (Yellow)
                [[0, 3, 3], [3, 3, 0], [0, 0, 0]],                       // S (Lime)
                [[4, 4, 0], [0, 4, 4], [0, 0, 0]],                       // Z (Red)
                [[5, 5, 5], [0, 5, 0], [0, 0, 0]],                       // T (Purple)
                [[6, 6, 6], [6, 0, 0], [0, 0, 0]],                       // L (Orange)
                [[7, 7, 7], [0, 0, 7], [0, 0, 0]]                        // J (Blue)
            ];

            const colors = [
                null, // 0 for empty
                '#06b6d4', // Cyan
                '#facc15', // Yellow
                '#84cc16', // Lime
                '#ef4444', // Red
                '#a855f7', // Purple
                '#f97316', // Orange
                '#3b82f6'  // Blue
            ];

            let currentPiece = null;
            let currentPosition = { x: 0, y: 0 };
            let score = 0;
            let gameInterval = null; // Use setInterval for consistent drop speed
            let dropSpeed = 1000; // Milliseconds per drop
            let isPaused = false;

            // Function to create a random piece
            function createPiece() {
                const randIndex = Math.floor(Math.random() * tetrominoes.length);
                const piece = JSON.parse(JSON.stringify(tetrominoes[randIndex])); // Deep copy
                return piece;
            }

            // Function to draw the board and pieces
            function draw() {
                // Clear the canvas
                context.fillStyle = '#1a202c'; // Dark background
                context.fillRect(0, 0, boardWidth, boardHeight);

                // Draw the board
                board.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (value !== 0) {
                            context.fillStyle = colors[value];
                            context.fillRect(x, y, 1, 1);
                            context.strokeStyle = '#2d3748'; // Dark stroke
                            context.lineWidth = 0.05; // Thin stroke
                            context.strokeRect(x, y, 1, 1);
                        }
                    });
                });

                // Draw the current piece
                if (currentPiece) {
                    currentPiece.forEach((row, y) => {
                        row.forEach((value, x) => {
                            if (value !== 0) {
                                context.fillStyle = colors[value];
                                context.fillRect(currentPosition.x + x, currentPosition.y + y, 1, 1);
                                context.strokeStyle = '#2d3748'; // Dark stroke
                                context.lineWidth = 0.05; // Thin stroke
                                context.strokeRect(currentPosition.x + x, currentPosition.y + y, 1, 1);
                            }
                        });
                    });
                }
            }

            // Function to merge the current piece into the board
            function merge() {
                currentPiece.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (value !== 0) {
                            // Ensure position is within board bounds before merging
                            if (currentPosition.y + y >= 0 && currentPosition.y + y < boardHeight &&
                                currentPosition.x + x >= 0 && currentPosition.x + x < boardWidth) {
                                board[currentPosition.y + y][currentPosition.x + x] = value;
                            }
                        }
                    });
                });
            }

            // Function to check for collisions
            function collide() {
                for (let y = 0; y < currentPiece.length; ++y) {
                    for (let x = 0; x < currentPiece[y].length; ++x) {
                        if (currentPiece[y][x] !== 0) {
                            const boardX = currentPosition.x + x;
                            const boardY = currentPosition.y + y;

                            // Check collision with bottom boundary or existing blocks
                            if (boardY >= boardHeight ||
                                boardX < 0 || boardX >= boardWidth ||
                                (board[boardY] && board[boardY][boardX]) !== 0) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            }

            // Function to rotate the piece
            function rotate(piece, dir) {
                // Transpose the matrix
                for (let y = 0; y < piece.length; ++y) {
                    for (let x = 0; x < y; ++x) {
                        [piece[x][y], piece[y][x]] = [piece[y][x], piece[x][y]];
                    }
                }

                // Reverse rows or columns based on direction
                if (dir > 0) {
                    piece.forEach(row => row.reverse());
                } else {
                    piece.reverse();
                }

                // Adjust position after rotation if it causes collision
                const originalPos = currentPosition.x;
                let offset = 1;
                while (collide()) {
                    currentPosition.x += offset;
                    offset = -(offset + (offset > 0 ? 1 : -1)); // Try 1, -2, 3, -4...
                    if (offset > piece[0].length + 1) { // Prevent infinite loop
                        rotate(piece, -dir); // Rotate back if cannot find a valid position
                        currentPosition.x = originalPos;
                        return;
                    }
                }
            }

            // Function to move the piece down
            function dropPiece() {
                if (isPaused) return;

                currentPosition.y++;
                if (collide()) {
                    currentPosition.y--;
                    merge();
                    removeLines();
                    currentPiece = createPiece();
                    currentPosition = { x: Math.floor(boardWidth / 2) - Math.floor(currentPiece[0].length / 2), y: 0 };
                    if (collide()) {
                        // Game over
                        showMessage('Game Over!');
                        clearInterval(gameInterval);
                        gameInterval = null;
                        board.forEach(row => row.fill(0)); // Clear board on game over
                        score = 0;
                        updateScore();
                        draw(); // Draw empty board
                    }
                }
                draw();
            }

            // Function to remove completed lines
            function removeLines() {
                let linesRemoved = 0;
                outer: for (let y = board.length - 1; y >= 0; --y) { // Iterate downwards
                    for (let x = 0; x < board[y].length; ++x) {
                        if (board[y][x] === 0) {
                            continue outer; // Skip to the next row if an empty cell is found
                        }
                    }

                    // Line is full, remove it
                    const row = board.splice(y, 1)[0].fill(0);
                    board.unshift(row); // Add a new empty row at the top
                    linesRemoved++;
                    y++; // Re-check the current row index as the rows have shifted down
                }
                if (linesRemoved > 0) {
                    score += linesRemoved * 100 * linesRemoved; // Scoring: 100 for 1, 400 for 2, 900 for 3, 1600 for 4
                    updateScore();
                    // Increase drop speed slightly for every few lines cleared
                    if (score > 0 && score % 1000 === 0 && dropSpeed > 100) {
                         dropSpeed -= 50; // Decrease interval
                         if (gameInterval) { // Restart interval with new speed if game is running
                              clearInterval(gameInterval);
                              gameInterval = setInterval(dropPiece, dropSpeed);
                         }
                         showMessage(`Speed increased! Drop interval: ${dropSpeed}ms`);
                    }

                }
            }

            // Update the score display
            function updateScore() {
                scoreDisplay.textContent = `Score: ${score}`;
            }

            // Handle keyboard input
            function handleKeyPress(event) {
                 if (!gameInterval || isPaused) return; // Only process input if game is running and not paused

                // Prevent default browser scrolling for arrow keys
                if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(event.key)) {
                    event.preventDefault();
                }


                if (event.key === 'ArrowLeft') {
                    currentPosition.x--;
                    if (collide()) {
                        currentPosition.x++;
                    }
                } else if (event.key === 'ArrowRight') {
                    currentPosition.x++;
                    if (collide()) {
                        currentPosition.x--;
                    }
                } else if (event.key === 'ArrowDown') {
                    dropPiece(); // Drop one step down immediately
                } else if (event.key === 'ArrowUp') {
                    rotate(currentPiece, 1); // Rotate clockwise
                }
                draw();
            }

            // Start the game
            startButton.addEventListener('click', () => {
                 if (!gameActive) {
                    resetGame(); // Reset before starting
                    gameActive = true;
                    gameInterval = setInterval(gameLoop, 1000 / 60); // Run at 60 FPS
                    draw(); // Initial draw
                    showMessage('Tetris game started!');
                 } else {
                     showMessage('Tetris game is already running.');
                 }
            });

             // Pause/Resume the game
            pauseButton.addEventListener('click', () => {
                if (gameInterval) {
                    isPaused = !isPaused;
                    pauseButton.textContent = isPaused ? 'Resume' : 'Pause';
                    showMessage(isPaused ? 'Tetris game paused.' : 'Tetris game resumed.');
                     if (!isPaused) {
                         // If resuming, restart the interval to continue dropping
                         gameInterval = setInterval(gameLoop, dropSpeed);
                     } else {
                         // If pausing, clear the interval
                         clearInterval(gameInterval);
                     }
                } else {
                    showMessage('No Tetris game is running to pause.');
                }
            });


            // Add keyboard event listener
            document.addEventListener('keydown', handleKeyPress);

             // Initial draw (empty board)
             draw();

             // Clean up function when switching games
             return () => {
                 clearInterval(gameInterval); // Clear the interval
                 document.removeEventListener('keydown', handleKeyPress);
                 gameInterval = null; // Reset game interval
                 isPaused = false; // Reset pause state
             };
        }

        // Card Matching Game
        function loadCardMatching() {
             gameArea.innerHTML = `
                <h2 class="text-2xl font-semibold text-center mb-6 text-gray-800">Card Matching</h2>
                <div id="card-matching-board" class="mx-auto">
                    </div>
                 <p id="card-matching-status" class="text-center mt-6 text-xl text-gray-700 font-semibold"></p>
                 <button id="card-matching-reset" class="block mx-auto mt-8 px-6 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50">Reset Game</button>
            `;

            const boardElement = document.getElementById('card-matching-board');
            const statusDisplay = document.getElementById('card-matching-status');
            const resetButton = document.getElementById('card-matching-reset');

            // Array of letter identifiers for card pairs
            const cardIdentifiers = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']; // Using letters
            let cards = [];
            let flippedCards = [];
            let matchedPairs = 0;
            let gameActive = true;
            let lockBoard = false; // To prevent flipping more than two cards at once

            // Function to create the cards
            function createCards() {
                // Use all identifiers for the game (8 pairs = 16 cards)
                cards = [...cardIdentifiers, ...cardIdentifiers]; // Create pairs
                shuffle(cards); // Shuffle the cards
                boardElement.innerHTML = ''; // Clear previous cards

                cards.forEach((identifier, index) => {
                    const cardElement = document.createElement('div');
                    cardElement.classList.add('card', 'rounded-lg', 'shadow-md');
                    cardElement.setAttribute('data-identifier', identifier); // Store identifier for matching
                    cardElement.setAttribute('data-index', index);

                     cardElement.innerHTML = `
                        <div class="card-inner">
                            <div class="card-back">?</div>
                            <div class="card-front">
                                ${identifier} </div>
                        </div>
                    `;

                    // Cards start face down, so no 'flipped' class initially
                    // cardElement.classList.add('flipped'); // REMOVED

                    // Add event listener now, but clicks will be blocked by lockBoard during initial reveal
                    cardElement.addEventListener('click', handleCardClick);
                    boardElement.appendChild(cardElement);
                });

                 statusDisplay.textContent = 'Memorize the pairs!';
                 matchedPairs = 0; // Reset matched pairs
                 gameActive = true; // Ensure game is active on reset/creation
                 lockBoard = true; // Lock the board during the initial reveal

                 // Set a timeout to reveal the cards, then flip them back
                 setTimeout(() => {
                     // Reveal the cards (flip to show letters)
                     document.querySelectorAll('.card').forEach(card => {
                         card.classList.add('flipped');
                     });

                     // Set another timeout to flip the cards back and unlock the board
                     setTimeout(() => {
                         document.querySelectorAll('.card').forEach(card => {
                             // Only remove 'flipped' if the card hasn't been matched during the reveal time (unlikely but safe)
                             if (!card.classList.contains('matched')) {
                                 card.classList.remove('flipped');
                             }
                         });
                         lockBoard = false; // Unlock the board after reveal
                         statusDisplay.textContent = 'Flip a card!';
                         showMessage('Go!'); // Indicate the game is ready
                     }, 2000); // Reveal duration (2 seconds)

                 }, 500); // Short delay before initial reveal starts (optional, makes it smoother)
            }

            // Function to shuffle an array (Fisher-Yates algorithm)
            function shuffle(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]]; // Swap elements
                }
                return array;
            }

            // Handle card click
            function handleCardClick(event) {
                const clickedCard = event.currentTarget;

                // If the board is locked, the card is already flipped or matched, do nothing
                if (lockBoard || clickedCard.classList.contains('flipped') || clickedCard.classList.contains('matched') || !gameActive) {
                    return;
                }

                // Flip the card
                clickedCard.classList.add('flipped');
                flippedCards.push(clickedCard);

                // If two cards are flipped, check for a match
                if (flippedCards.length === 2) {
                    lockBoard = true; // Lock the board while checking
                    checkMatch();
                }
            }

            // Check if the two flipped cards match
            function checkMatch() {
                const [card1, card2] = flippedCards;
                const identifier1 = card1.getAttribute('data-identifier');
                const identifier2 = card2.getAttribute('data-identifier');

                if (identifier1 === identifier2) {
                    // Match!
                    card1.classList.add('matched');
                    card2.classList.add('matched');
                    // Remove event listeners from matched cards (optional, but good practice)
                    // card1.removeEventListener('click', handleCardClick); // Keeping listeners allows clicking matched cards, which is harmless
                    // card2.removeEventListener('click', handleCardClick);

                    matchedPairs++;
                    flippedCards = []; // Clear flipped cards
                    lockBoard = false; // Unlock the board

                    // Check if all pairs are matched
                    if (matchedPairs === cardIdentifiers.length) { // Compare with the number of unique identifiers used
                        statusDisplay.textContent = 'You matched all pairs! You win!';
                         showMessage('You matched all pairs! You win!');
                        gameActive = false;
                    } else {
                         statusDisplay.textContent = 'Match found! Keep going!';
                         showMessage('Match found!');
                    }

                } else {
                    // No match, flip back after a delay
                     statusDisplay.textContent = 'No match. Try again!';
                     showMessage('No match.');
                    setTimeout(() => {
                        card1.classList.remove('flipped');
                        card2.classList.remove('flipped');
                        flippedCards = []; // Clear flipped cards
                        lockBoard = false; // Unlock the board
                         statusDisplay.textContent = 'Flip a card!';
                    }, 1000); // Flip back after 1 second
                }
            }

            // Reset the game
            function resetGame() {
                flippedCards = [];
                matchedPairs = 0;
                gameActive = true;
                lockBoard = false; // Ensure board is unlocked on reset
                createCards(); // Recreate and shuffle cards (which includes the initial reveal)
                 showMessage('Card Matching game reset.');
            }

            // Add reset button event listener
            resetButton.addEventListener('click', resetGame);

            // Initial game setup
            createCards();
        }

        // Ping Pong Game
        function loadPingPong() {
            gameArea.innerHTML = `
                <h2 class="text-2xl font-semibold text-center mb-6 text-gray-800">Ping Pong</h2>
                <canvas id="ping-pong-board" width="600" height="400"></canvas>
                <div class="text-center mt-4 text-xl text-gray-700 font-semibold font-['Press_Start_2P']">
                    <span id="ping-pong-player-score">0</span> - <span id="ping-pong-ai-score">0</span>
                </div>
                <div class="text-center mt-6 space-x-4">
                    <button id="ping-pong-start" class="px-6 py-3 bg-green-600 text-white rounded-lg hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-opacity-50">Start</button>
                    <button id="ping-pong-reset" class="px-6 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50">Reset</button>
                </div>
                 <p class="text-center mt-4 text-gray-600 text-sm">Use W and S keys to move your paddle.</p>
            `;

            const canvas = document.getElementById('ping-pong-board');
            const context = canvas.getContext('2d');
            const playerScoreDisplay = document.getElementById('ping-pong-player-score');
            const aiScoreDisplay = document.getElementById('ping-pong-ai-score');
            const startButton = document.getElementById('ping-pong-start');
            const resetButton = document.getElementById('ping-pong-reset');

            // Game variables
            const paddleWidth = 10;
            const paddleHeight = 80;
            let playerPaddleY = (canvas.height - paddleHeight) / 2;
            let aiPaddleY = (canvas.height - paddleHeight) / 2;
            const ballSize = 10;
            let ballX = canvas.width / 2;
            let ballY = canvas.height / 2;
            let ballSpeedX = 5;
            let ballSpeedY = 5;
            let playerScore = 0;
            let aiScore = 0;
            const winningScore = 5; // First to 5 wins
            let gameInterval = null;
            let gameActive = false;

            // Input handling
            let keysPressed = {};
            document.addEventListener('keydown', (event) => {
                keysPressed[event.key] = true;
            });
            document.addEventListener('keyup', (event) => {
                keysPressed[event.key] = false;
            });

            // Draw elements
            function drawRect(x, y, width, height, color) {
                context.fillStyle = color;
                context.fillRect(x, y, width, height);
            }

            function drawCircle(x, y, radius, color) {
                context.fillStyle = color;
                context.beginPath();
                context.arc(x, y, radius, 0, Math.PI * 2, false);
                context.fill();
            }

            function draw() {
                // Background
                drawRect(0, 0, canvas.width, canvas.height, '#1a202c');

                // Paddles
                drawRect(0, playerPaddleY, paddleWidth, paddleHeight, '#e2e8f0'); // Player paddle
                drawRect(canvas.width - paddleWidth, aiPaddleY, paddleWidth, paddleHeight, '#e2e8f0'); // AI paddle

                // Ball
                drawCircle(ballX, ballY, ballSize / 2, '#fde047'); // Yellow ball

                // Center line (optional)
                for (let i = 0; i < canvas.height; i += 15) {
                    drawRect(canvas.width / 2 - 1, i, 2, 10, '#4a5568');
                }
            }

            // Move elements
            function move() {
                if (!gameActive) return;

                // Move player paddle
                if (keysPressed['w'] && playerPaddleY > 0) {
                    playerPaddleY -= 7;
                }
                if (keysPressed['s'] && playerPaddleY < canvas.height - paddleHeight) {
                    playerPaddleY += 7;
                }

                // Move AI paddle (simple AI)
                const aiCenter = aiPaddleY + paddleHeight / 2;
                if (aiCenter < ballY - 10) {
                    aiPaddleY += 4;
                } else if (aiCenter > ballY + 10) {
                    aiPaddleY -= 4;
                }
                 // Keep AI paddle within bounds
                 aiPaddleY = Math.max(0, Math.min(canvas.height - paddleHeight, aiPaddleY));


                // Move ball
                ballX += ballSpeedX;
                ballY += ballSpeedY;

                // Ball collision with top/bottom walls
                if (ballY - ballSize / 2 < 0 || ballY + ballSize / 2 > canvas.height) {
                    ballSpeedY *= -1;
                }

                // Ball collision with paddles
                // Player paddle
                if (ballX - ballSize / 2 < paddleWidth && ballY > playerPaddleY && ballY < playerPaddleY + paddleHeight) {
                    ballSpeedX *= -1;
                     // Add slight vertical speed based on where the ball hit the paddle
                     const deltaY = ballY - (playerPaddleY + paddleHeight / 2);
                     ballSpeedY = deltaY * 0.35; // Adjust multiplier for desired effect
                }

                // AI paddle
                if (ballX + ballSize / 2 > canvas.width - paddleWidth && ballY > aiPaddleY && ballY < aiPaddleY + paddleHeight) {
                    ballSpeedX *= -1;
                     // Add slight vertical speed based on where the ball hit the paddle
                     const deltaY = ballY - (aiPaddleY + paddleHeight / 2);
                     ballSpeedY = deltaY * 0.35; // Adjust multiplier for desired effect
                }


                // Ball out of bounds (scoring)
                if (ballX - ballSize / 2 < 0) {
                    aiScore++;
                    updateScore();
                    resetBall();
                    checkWin();
                } else if (ballX + ballSize / 2 > canvas.width) {
                    playerScore++;
                    updateScore();
                    resetBall();
                    checkWin();
                }
            }

            // Reset ball position and speed
            function resetBall() {
                ballX = canvas.width / 2;
                ballY = canvas.height / 2;
                // Reverse direction after scoring
                ballSpeedX = -ballSpeedX;
                // Randomize vertical speed slightly
                ballSpeedY = (Math.random() * 10) - 5; // Between -5 and 5
            }

            // Update score display
            function updateScore() {
                playerScoreDisplay.textContent = playerScore;
                aiScoreDisplay.textContent = aiScore;
            }

            // Check for win condition
            function checkWin() {
                if (playerScore >= winningScore) {
                    showMessage('Player Wins!');
                    stopGame();
                } else if (aiScore >= winningScore) {
                    showMessage('AI Wins!');
                    stopGame();
                }
            }

            // Game loop
            function gameLoop() {
                move();
                draw();
            }

            // Start game
            startButton.addEventListener('click', () => {
                 if (!gameActive) {
                    resetGame(); // Reset before starting
                    gameActive = true;
                    gameInterval = setInterval(gameLoop, 1000 / 60); // Run at 60 FPS
                    draw(); // Initial draw
                    showMessage('Ping Pong game started!');
                 } else {
                     showMessage('Ping Pong game is already running.');
                 }
            });

            // Reset game
            resetButton.addEventListener('click', () => {
                stopGame();
                resetGame();
                 showMessage('Ping Pong game reset.');
            });

            // Stop game
            function stopGame() {
                clearInterval(gameInterval);
                gameInterval = null;
                gameActive = false;
            }

            // Reset game state
            function resetGame() {
                 playerScore = 0;
                 aiScore = 0;
                 updateScore();
                 playerPaddleY = (canvas.height - paddleHeight) / 2;
                 aiPaddleY = (canvas.height - paddleHeight) / 2;
                 resetBall();
                 draw(); // Draw initial state
            }


            // Initial draw
            draw();

            // Cleanup function
            return () => {
                stopGame();
                // Remove event listeners if necessary (though they are on document,
                // they won't affect other games unless they use the same keys)
                // For simplicity, we'll rely on the gameActive flag within the listeners.
            };
        }

        // Projectile Launch Game
        function loadProjectileGame() {
            gameArea.innerHTML = `
                <h2 class="text-2xl font-semibold text-center mb-6 text-gray-800">Projectile Game</h2>
                <canvas id="projectile-board" width="800" height="400"></canvas>
                <div class="text-center mt-4">
                     <span id="level-display" class="text-gray-700 font-semibold mr-4">Level: 1</span>
                    <label for="launch-angle" class="text-gray-700 font-semibold">Angle:</label>
                    <input type="range" id="launch-angle" min="0" max="90" value="45">
                    <span id="angle-value" class="text-gray-700">45Â°</span>

                    <label for="launch-power" class="text-gray-700 font-semibold ml-4">Power:</label>
                    <input type="range" id="launch-power" min="10" max="100" value="50">
                    <span id="power-value" class="text-gray-700">50</span>
                </div>
                <div class="text-center mt-6 space-x-4">
                    <button id="projectile-launch" class="px-6 py-3 bg-green-600 text-white rounded-lg hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-opacity-50">Launch</button>
                    <button id="projectile-reset" class="px-6 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50">Reset</button>
                </div>
                 <p id="projectile-status" class="text-center mt-4 text-xl text-gray-700 font-semibold"></p>
            `;

            const canvas = document.getElementById('projectile-board');
            const context = canvas.getContext('2d');
            const angleInput = document.getElementById('launch-angle');
            const angleValueSpan = document.getElementById('angle-value');
            const powerInput = document.getElementById('launch-power');
            const powerValueSpan = document.getElementById('power-value');
            const launchButton = document.getElementById('projectile-launch');
            const resetButton = document.getElementById('projectile-reset');
            const statusDisplay = document.getElementById('projectile-status');
            const levelDisplay = document.getElementById('level-display');


            // Game variables
            const gravity = 0.5; // Pixels per frame^2
            const bounceDampening = 0.8; // Factor to reduce velocity on bounce
            let projectile = { x: 50, y: canvas.height - 50, radius: 10, color: '#fde047', velocityX: 0, velocityY: 0 };
            let isProjectileLaunched = false;
            let animationFrameId = null; // To cancel animation frame

            // Level configurations
            const levels = [
                // Level 1
                {
                    target: { x: canvas.width - 100, y: canvas.height - 30, radius: 15, color: '#ef4444' },
                    obstacles: [
                        { x: 300, y: canvas.height - 100, width: 20, height: 70, color: '#4a5568' }
                    ]
                },
                // Level 2
                {
                    target: { x: canvas.width - 150, y: canvas.height - 30, radius: 15, color: '#ef4444' },
                    obstacles: [
                        { x: 350, y: canvas.height - 150, width: 20, height: 120, color: '#4a5568' }
                    ]
                },
                // Level 3
                {
                    target: { x: canvas.width - 200, y: canvas.height - 30, radius: 15, color: '#ef4444' },
                    obstacles: [
                        { x: 400, y: canvas.height - 120, width: 20, height: 90, color: '#4a5568' },
                        { x: 550, y: canvas.height - 180, width: 20, height: 150, color: '#4a5568' }
                    ]
                },
                // Level 4
                {
                    target: { x: canvas.width - 100, y: canvas.height - 80, radius: 15, color: '#ef4444' }, // Higher target
                    obstacles: [
                        { x: 400, y: canvas.height - 100, width: 100, height: 20, color: '#4a5568' } // Horizontal obstacle
                    ]
                },
                 // Level 5
                {
                    target: { x: canvas.width - 150, y: canvas.height - 30, radius: 15, color: '#ef4444' },
                    obstacles: [
                        { x: 300, y: canvas.height - 180, width: 20, height: 150, color: '#4a5568' },
                        { x: 500, y: canvas.height - 100, width: 20, height: 70, color: '#4a5568' }
                    ]
                },
                 // Level 6
                {
                    target: { x: canvas.width - 250, y: canvas.height - 120, radius: 15, color: '#ef4444' }, // Higher and further target
                    obstacles: [
                        { x: 400, y: canvas.height - 150, width: 20, height: 120, color: '#4a5568' },
                        { x: 550, y: canvas.height - 80, width: 100, height: 20, color: '#4a5568' } // Horizontal obstacle
                    ]
                },
                 // Level 7
                {
                    target: { x: canvas.width - 80, y: canvas.height - 150, radius: 15, color: '#ef4444' }, // High target, close
                    obstacles: [
                        { x: 250, y: canvas.height - 100, width: 20, height: 70, color: '#4a5568' },
                        { x: 400, y: canvas.height - 200, width: 20, height: 170, color: '#4a5568' },
                         { x: 550, y: canvas.height - 100, width: 20, height: 70, color: '#4a5568' }
                    ]
                },
                 // Level 8
                {
                    target: { x: canvas.width - 180, y: canvas.height - 30, radius: 15, color: '#ef4444' },
                    obstacles: [
                        { x: 300, y: canvas.height - 120, width: 150, height: 20, color: '#4a5568' }, // Horizontal
                        { x: 500, y: canvas.height - 220, width: 150, height: 20, color: '#4a5568' }  // Horizontal higher up
                    ]
                },
                 // Level 9
                {
                    target: { x: canvas.width - 100, y: canvas.height - 200, radius: 15, color: '#ef4444' }, // Very high target
                    obstacles: [
                        { x: 300, y: canvas.height - 100, width: 20, height: 70, color: '#4a5568' },
                        { x: 450, y: canvas.height - 150, width: 20, height: 120, color: '#4a5568' },
                         { x: 600, y: canvas.height - 200, width: 20, height: 170, color: '#4a5568' }
                    ]
                },
                 // Level 10 (Final Level)
                {
                    target: { x: canvas.width - 50, y: canvas.height - 250, radius: 15, color: '#ef4444' }, // Highest and furthest target
                    obstacles: [
                        { x: 200, y: canvas.height - 100, width: 20, height: 70, color: '#4a5568' },
                        { x: 350, y: canvas.height - 180, width: 100, height: 20, color: '#4a5568' }, // Horizontal
                        { x: 500, y: canvas.height - 200, width: 20, height: 170, color: '#4a5568' },
                         { x: 650, y: canvas.height - 120, width: 100, height: 20, color: '#4a5568' } // Horizontal
                    ]
                }
            ];

            let currentLevelIndex = 0;
            let currentLevel = levels[currentLevelIndex];


            // Update angle and power displays
            angleInput.addEventListener('input', () => {
                angleValueSpan.textContent = `${angleInput.value}Â°`;
                 if (!isProjectileLaunched) draw(); // Redraw launcher angle if not launched
            });
            powerInput.addEventListener('input', () => {
                powerValueSpan.textContent = powerInput.value;
                 if (!isProjectileLaunched) draw(); // Redraw launcher power if not launched
            });


            // Draw elements
            function drawRect(x, y, width, height, color) {
                context.fillStyle = color;
                context.fillRect(x, y, width, height);
            }

            function drawCircle(x, y, radius, color) {
                context.fillStyle = color;
                context.beginPath();
                context.arc(x, y, radius, 0, Math.PI * 2, false);
                context.fill();
            }

            function drawLine(x1, y1, x2, y2, color, width) {
                 context.strokeStyle = color;
                 context.lineWidth = width;
                 context.beginPath();
                 context.moveTo(x1, y1);
                 context.lineTo(x2, y2);
                 context.stroke();
            }


            function draw() {
                // Background
                drawRect(0, 0, canvas.width, canvas.height, '#a0aec0'); // Lighter background

                // Ground
                drawRect(0, canvas.height - 30, canvas.width, 30, '#718096'); // Ground color

                // Launcher (simple line indicating angle/power)
                 if (!isProjectileLaunched) {
                     const angle = parseInt(angleInput.value);
                     const power = parseInt(powerInput.value);
                     const radians = angle * Math.PI / 180;
                     const lineLength = power * 1.5; // Increased line length for visual feedback
                     const endX = projectile.x + lineLength * Math.cos(radians);
                     const endY = projectile.y - lineLength * Math.sin(radians);
                     drawLine(projectile.x, projectile.y, endX, endY, '#2d3748', 3);
                 }


                // Projectile
                drawCircle(projectile.x, projectile.y, projectile.radius, projectile.color);

                // Target
                drawCircle(currentLevel.target.x, currentLevel.target.y - currentLevel.target.radius, currentLevel.target.radius, currentLevel.target.color); // Draw target on the ground


                // Obstacles
                currentLevel.obstacles.forEach(obstacle => {
                    drawRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height, obstacle.color);
                });

                 // Update level display
                 levelDisplay.textContent = `Level: ${currentLevelIndex + 1}`;
            }

            // Update game state
            function update() {
                if (isProjectileLaunched) {
                    // Apply gravity
                    projectile.velocityY += gravity;

                    // Update position
                    projectile.x += projectile.velocityX;
                    projectile.y += projectile.velocityY;

                    // Check collision with ground
                    if (projectile.y + projectile.radius > canvas.height - 30) {
                        projectile.y = canvas.height - 30 - projectile.radius; // Place on ground
                        projectile.velocityX *= bounceDampening; // Dampen horizontal velocity on ground bounce
                        projectile.velocityY *= -bounceDampening; // Reverse and dampen vertical velocity
                         // If vertical velocity is very small after bounce, stop it
                         if (Math.abs(projectile.velocityY) < 1) {
                             projectile.velocityY = 0;
                         }
                         // If horizontal velocity is very small, stop simulation
                         if (Math.abs(projectile.velocityX) < 1 && projectile.velocityY === 0) {
                             isProjectileLaunched = false; // Stop simulation
                             statusDisplay.textContent = 'Landed!';
                             showMessage('Landed!');
                             // Stop animation loop
                             if (animationFrameId) {
                                 cancelAnimationFrame(animationFrameId);
                                 animationFrameId = null;
                             }
                         }
                    }

                    // Check collision with target
                    const distanceToTarget = Math.sqrt(Math.pow(projectile.x - currentLevel.target.x, 2) + Math.pow(projectile.y - (currentLevel.target.y - currentLevel.target.radius), 2));
                    if (distanceToTarget < projectile.radius + currentLevel.target.radius) {
                        // Hit the target!
                        isProjectileLaunched = false; // Stop simulation
                         // Stop animation loop
                         if (animationFrameId) {
                             cancelAnimationFrame(animationFrameId);
                             animationFrameId = null;
                         }

                        // Check if it's the last level
                        if (currentLevelIndex === levels.length - 1) {
                            statusDisplay.textContent = 'You Win!';
                             showMessage('You Win!');
                        } else {
                            statusDisplay.textContent = 'Level Complete!';
                             showMessage('Level Complete!');
                            currentLevelIndex++; // Move to the next level
                            currentLevel = levels[currentLevelIndex];
                            resetGame(); // Reset for the next level
                        }
                    }

                    // Check collision with obstacles (simple bounding box collision)
                    currentLevel.obstacles.forEach(obstacle => {
                        // Calculate the closest point on the obstacle to the projectile center
                        const closestX = Math.max(obstacle.x, Math.min(projectile.x, obstacle.x + obstacle.width));
                        const closestY = Math.max(obstacle.y, Math.min(projectile.y, obstacle.y + obstacle.height));

                        // Calculate the distance between the projectile center and the closest point
                        const distanceX = projectile.x - closestX;
                        const distanceY = projectile.y - closestY;
                        const distanceSquared = (distanceX * distanceX) + (distanceY * distanceY);

                        // If the distance is less than the projectile radius, there's a collision
                        if (distanceSquared < (projectile.radius * projectile.radius)) {
                            // Determine which side of the obstacle was hit
                            const prevProjectileX = projectile.x - projectile.velocityX;
                            const prevProjectileY = projectile.y - projectile.velocityY;

                            const hitFromLeft = prevProjectileX + projectile.radius <= obstacle.x && projectile.x + projectile.radius > obstacle.x;
                            const hitFromRight = prevProjectileX - projectile.radius >= obstacle.x + obstacle.width && projectile.x - projectile.radius < obstacle.x + obstacle.width;
                            const hitFromTop = prevProjectileY + projectile.radius <= obstacle.y && projectile.y + projectile.radius > obstacle.y;
                            const hitFromBottom = prevProjectileY - projectile.radius >= obstacle.y + obstacle.height && projectile.y - projectile.radius < obstacle.y + obstacle.height;

                            if (hitFromLeft || hitFromRight) {
                                projectile.velocityX *= -bounceDampening; // Reverse and dampen horizontal velocity
                                // Adjust position to prevent sticking
                                if (hitFromLeft) projectile.x = obstacle.x - projectile.radius;
                                if (hitFromRight) projectile.x = obstacle.x + obstacle.width + projectile.radius;
                            }

                            if (hitFromTop || hitFromBottom) {
                                projectile.velocityY *= -bounceDampening; // Reverse and dampen vertical velocity
                                // Adjust position to prevent sticking
                                if (hitFromTop) projectile.y = obstacle.y - projectile.radius;
                                if (hitFromBottom) projectile.y = obstacle.y + obstacle.height + projectile.radius;
                            }

                            // If hit a corner, both velocities might be reversed
                            // No need to stop the simulation here, just bounce
                        }
                    });


                     // Check if projectile is out of bounds horizontally
                    if (projectile.x > canvas.width || projectile.x < 0) {
                         statusDisplay.textContent = 'Out of Bounds!';
                         showMessage('Out of Bounds!');
                         isProjectileLaunched = false; // Stop simulation
                          // Stop animation loop
                         if (animationFrameId) {
                             cancelAnimationFrame(animationFrameId);
                             animationFrameId = null;
                         }
                    }


                }
            }

            // Game loop
            function gameLoop() {
                update();
                draw();
                if (isProjectileLaunched) {
                    animationFrameId = requestAnimationFrame(gameLoop);
                }
            }

            // Launch projectile
            launchButton.addEventListener('click', () => {
                if (!isProjectileLaunched) {
                    const angle = parseInt(angleInput.value);
                    const power = parseInt(powerInput.value);
                    const radians = angle * Math.PI / 180;

                    // Calculate initial velocity components with increased multiplier
                    const initialVelocityMultiplier = 0.2; // Increased multiplier
                    projectile.velocityX = power * initialVelocityMultiplier * Math.cos(radians);
                    projectile.velocityY = -power * initialVelocityMultiplier * Math.sin(radians); // Negative because canvas Y is down

                    isProjectileLaunched = true;
                    statusDisplay.textContent = 'Launching...';
                    gameLoop(); // Start the animation loop
                } else {
                    showMessage('Projectile already launched!');
                }
            });

            // Reset game
            resetButton.addEventListener('click', () => {
                currentLevelIndex = 0; // Reset to the first level
                currentLevel = levels[currentLevelIndex];
                resetGame();
                 showMessage('Projectile game reset.');
            });

            // Reset game state
            function resetGame() {
                isProjectileLaunched = false;
                projectile = { x: 50, y: canvas.height - 50, radius: 10, color: '#fde047', velocityX: 0, velocityY: 0 };
                statusDisplay.textContent = '';
                 // Cancel any ongoing animation frame
                 if (animationFrameId) {
                     cancelAnimationFrame(animationFrameId);
                     animationFrameId = null;
                 }
                draw(); // Draw initial state
            }

            // Initial game setup
            resetGame(); // Start at level 1

            // Cleanup function
            return () => {
                 // Cancel any ongoing animation frame when switching games
                 if (animationFrameId) {
                     cancelAnimationFrame(animationFrameId);
                     animationFrameId = null;
                 }
                 // No need to remove event listeners on range inputs/buttons
                 // as they are children of gameArea which is cleared.
            };
        }


        // --- Game Loading Logic ---

        // Variable to store the cleanup function of the currently loaded game
        let currentGameCleanup = null;

        // Function to load a game
        function loadGame(gameName) {
             // Run cleanup for the previous game if it exists
            if (currentGameCleanup) {
                currentGameCleanup();
            }

            // Load the selected game
            switch (gameName) {
                case 'tic-tac-toe':
                    loadTicTacToe();
                    currentGameCleanup = null; // Tic Tac Toe doesn't need specific cleanup for now
                    break;
                case 'tetris':
                    currentGameCleanup = loadTetris(); // Tetris returns a cleanup function
                    break;
                case 'card-matching':
                    loadCardMatching();
                     currentGameCleanup = null; // Card Matching doesn't need specific cleanup for now
                    break;
                case 'ping-pong':
                    currentGameCleanup = loadPingPong(); // Ping Pong returns a cleanup function
                    break;
                case 'projectile':
                    currentGameCleanup = loadProjectileGame(); // Projectile Game returns a cleanup function
                    break;
                default:
                    gameArea.innerHTML = '<h2 class="text-2xl font-semibold text-center mb-4 text-gray-800">Select a game from the menu above!</h2>';
                    currentGameCleanup = null;
            }
        }

        // Add event listeners to game links
        document.querySelectorAll('.game-link').forEach(link => {
            link.addEventListener('click', (event) => {
                event.preventDefault(); // Prevent default link behavior
                const gameToLoad = event.target.getAttribute('data-game');
                loadGame(gameToLoad);
            });
        });

        // Load a default message on page load
        window.addEventListener('load', () => {
             gameArea.innerHTML = '<h2 class="text-2xl font-semibold text-center mb-4 text-gray-800">Select a game from the menu above!</h2>';
             showMessage('Welcome to the Minigame Arcade!');
        });

    </script>

</body>
</html>
